#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

#define rep(i,n) for (long long i = 0; i < static_cast<long long>((n)); i++)

using namespace std;

// 操作回数 f(n)
// 1 -> 1 (0)
// 2 -> 1,1 (1)
// 3 -> 2,1 (1 + 1 + 0 = 2)
// 4 -> 2,2 (1 + 1 + 1 = 3)
// 5 -> 3,2 (1 + 2 + 1 = 4)
// 6 -> 3,3 (1 + 2 + 2 = 5)
// 7 -> 4,3 (1 + 3 + 2 = 6)
// 8 -> 4,4 (1 + 3 + 3 = 7)
// 9 -> 5,4 (1 + 4 + 3 = 8)
// ...
// k = 1..n-1 について、操作回数 f(k) = k - 1 と仮定する。
// (i) n が偶数だとすると、f(n) = 1 + f(n/2) + f(n/2) = 1 + (n/2 - 1) + (n/2 - 1) = n - 1
// (ii) n が奇数だとすると、f(n) = 1 + f(n/2) + f(n/2 + 1) = 1 + (n/2 - 1) + n/2 = n - 1

// 金額 g(n)
// 2 -> 1,1 (2)
// 3 -> 2,1 (3 + 2 + 0 = 5) +3
// 4 -> 2,2 (4 + 2 + 2 = 8)
// 5 -> 3,2 (5 + 5 + 2 = 12) +4
// 6 -> 3,3 (6 + 5 + 5 = 16)
// 7 -> 4,3 (7 + 8 + 5 = 20)
// 8 -> 4,4 (8 + 8 + 8 = 24)
// 9 -> 5,4 (9 + 12 + 8 = 29) +5
// 10 -> 5,5 (10 + 12 + 12 = 34)
// 11 -> 6,5 (11 + 16 + 12 = 39)
// 12 -> 6,6 (12 + 16 + 16 = 44)
// 13 -> 7,6 (13 + 20 + 16 = 49)
// 14 -> 7,7 (14 + 20 + 20 = 54)
// 15 -> 8,7 (15 + 24 + 20 = 59)
// 16 -> 8,8 (16 + 24 + 24 = 64)
// 17 -> 9,8 (17 + 29 + 24 = 70) +6
// ...
// 2^n + 1 のところで公差が + (n+2) に変わっているように見える。
// g(2^n) = g(2^n) + 2*g(2^(n-1))

long g(long a) {  // a = 2^k
    if (a == 2) {
        return a;
    }
    else {
        return a + 2*g(a/2);
    }
}

int main() {
    long n;
    cin >> n;

    long a, b, k;  // n = a + b, a = 2^k
    a = 1;
    k = 0;
    while (2*a <= n) {
        a *= 2;
        k++;
    }
    b = n - a;

    long ans = g(a) + (k + 2)*b;
    cout << ans << endl;
}
